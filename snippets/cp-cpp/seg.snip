snippet     segmenttree
abbr        struct SegTree {};
alias       seg
  /// --- SegmentTree Library {{{ ///
  
  template <typename T> function<T(T,T)> constexpr mmin(){ return [](T x, T y){return x<y?x:y;}; }
  template <typename T> function<T(T,T)> constexpr mmax(){ return [](T x, T y){return x>y?x:y;}; }
  template <typename T> function<T(T,T)> constexpr madd(){ return [](T x, T y){return x+y;}; }
  
  template<typename T, int SIZE, T DEF, function<T(T,T)> &FUNC>
  struct SegTree {
    T data[SIZE*4];
    int m;
    SegTree(){
      init(SIZE);
    }
    void init(int sz) {
      m=1;
      while(m<sz) m<<=1;
      REP(i, m*2-1) data[i] = DEF;
    }
    void update(int i, T x) {
      i += m-1;
      data[i] = x;
      while(i>0) {
        i = (i-1)>>1;
        data[i] = FUNC(data[i*2+1], data[i*2+2]);
      }
    }
    T query(int a, int b, int k=0,int l=0, int r=-1) {
      if(r<0) r=m;
      if(b<=l||r<=a) return DEF;
      if(a<=l&&r<=b) return data[k];
      return FUNC(
          query(a, b, k*2+1, l, (l+r)/2),
          query(a, b, k*2+2, (l+r)/2, r)
          );
    }
    T get(int i) {
      return data[i + m - 1];
    }
    void dum(int l = -1, int r = -1) {
  #ifdef DEBUG
      if(l<0) l = 0;
      if(r<0) r = m;
      l = max(0, l);
      r = min(m, r);
      cerr<<l<<"[";
      FOR(i, l, r) {
        cerr<<get(i)<<(i!=r-1?", ":"");
      }
      cerr<<"]"<<r<<endl;
  #endif
    }
  };
  
  /// }}}--- ///
  
  auto imin = mmin<int>();
  auto imax = mmax<int>();
  auto iadd = madd<ll>();
  
  using RMinQ = SegTree<int, N,  INF, imin>;
  using RMaxQ = SegTree<int, N, -INF, imax>;
  using RSQ = SegTree<ll, N, 0, iadd>;
  
  RMinQ tree;

