snippet     fractionalcascadingsegtree
alias       segfractionalcascading fcseg
options     head
  // データ構造を乗せるためのセグ木の高速版
  // オフラインなら予めxごとに求めるyを与える
  // クエリはトップダウン
  // オンラインならDrivableSegTreeにBITとか乗せるしかない?
  /// --- Fractional Cascading SegmentTree Library {{{ ///
  
  template<class T, class U, class Index = long long>
  struct FractionalCascadingSegTree {
    int n;
    vector<T> dat;
    vector< vector<Index> > indices;
    vector< vector<int> > L, R;
    U identity;
    function<void(T&, int, const U& a)> upd;
    function<U(T&, int, int)> f;
    function<U(const U&, const U&)> m;
    FractionalCascadingSegTree() {}
    FractionalCascadingSegTree(int t,
        function<void(T&, int, const U& a)> const &upd,
        function<U(T&, int, int)> const &f,
        function<U(const U&, const U&)> const &m,
        U identity = U(), T initial = T())
      : identity(identity), upd(upd), f(f), m(m) {
        n = 1; while(n < t) n <<= 1;
        dat = vector<T>(2 * n, initial);
        indices = vector< vector<Index> >(2 * n);
        L = R = vector< vector<int> >(2 * n);
      }
    void index(int i, Index j) {
      indices[i + n - 1].emplace_back(j);
    }
    void init(function<void(T&, vector<int> indices)> h) {
      for(int i = n * 2 - 2; i >= 0; i--) {
        if(i >= n - 1) {
          sort(begin(indices[i]), end(indices[i]));
          indices[i].erase(unique(begin(indices[i]), end(indices[i])), end(indices[i]));
          h(dat[i], indices[i]);
          continue;
        }
        size_t lsz = indices[i * 2 + 1].size();
        size_t rsz = indices[i * 2 + 2].size();
        size_t nsz = lsz + rsz;
        h(dat[i], nsz);
        indices[i].resize(nsz); L[i].resize(nsz + 1, lsz); R[i].resize(nsz + 1, rsz);
        size_t p1 = 0, p2 = 0;
        while(p1 < lsz || p2 < rsz) {
          L[i][p1 + p2] = p1; R[i][p1 + p2] = p2;
          if(p1 < lsz &&
              (p2 == rsz || indices[i * 2 + 1][p1] <= indices[i * 2 + 2][p2])) {
            indices[i][p1 + p2] = indices[i * 2 + 1][p1]; p1++;
          } else {
            indices[i][p1 + p2] = indices[i * 2 + 2][p2]; p2++;
          }
        }
      }
    }
    void update(int i, int j, U const &val) {
      int lower = lower_bound(begin(indices[0]), end(indices[0]), j) - begin(indices[0]);
      update(i, lower, val, 0, n, 0);
    }
    void update(int i, int lower, U const &val, int l, int r, int k) {
      if(i+1 <= l || r <= i) return;
      upd(dat[k], lower, val);
      if(i <= l && r <= i+1) return;
      update(i, L[k][lower], val, l, (l + r) >> 1, k * 2 + 1);
      update(i, R[k][lower], val, (l + r) >> 1, r, k * 2 + 2);
    }
    U query(int a, int b, int l, int r) {
      int lower = lower_bound(begin(indices[0]), end(indices[0]), l) - begin(indices[0]);
      int upper = lower_bound(begin(indices[0]), end(indices[0]), r) - begin(indices[0]);
      return query(a, b, lower, upper, 0, n, 0);
    }
    U query(int a, int b, int lower, int upper, int l, int r, int k) {
      if(b <= l || r <= a) return identity;
      if(a <= l && r <= b) return f(dat[k], lower, upper);
      return m(
          query(a, b, L[k][lower], L[k][upper], l, (l + r) >> 1, k * 2 + 1),
          query(a, b, R[k][lower], R[k][upper], (l + r) >> 1, r, k * 2 + 2)
          );
    }
  };
  
  /// }}}--- ///
  
  // expamle {{{
  
  // FractionalCascadingSegTree<BIT<>, ll> ecas(N + 1,
  //     [](BIT<> &bit, int i, ll const &x) {
  //     bit.set(i, x);
  //     },
  //     [](BIT<> &bit, int l, int r) {
  //     return bit.range(l, r-1);
  //     },
  //     [](ll a, ll b) {
  //     return a + b;
  //     });
  
  // }}}
  
  // FractionalCascadingSegTree<BIT<>, ll> ecas(size, upd: (&bit, i, &dat) -> void, f: (&bit, [l, r)) -> ll, merge)
  // index(int x, int y)
  // init(f: (bit, size, indices) -> void)
  // update(int x, int y, value)
  ${0}

