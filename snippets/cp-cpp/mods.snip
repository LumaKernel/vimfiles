snippet     mods
options     head
  /// --- MOD Library {{{ ///
  
  constexpr ll extgcd(ll a, ll b, ll& x, ll& y) {
    if(b==0) {
      x = 1; y = 0;
      return a;
    }
    ll d = extgcd(b, a % b, y, x);
    y += (a / b) * x;
    return d;
  }
  constexpr int modadd(int a, int b, int mod = MOD) { return (((a + b) % mod ) + mod ) % mod; }
  constexpr void sadd(int &a, int b, int mod = MOD) { a = modadd(a, b, mod); }
  constexpr int modmul(int a, int b, int mod = MOD) { return (ll) (a % mod) * (b % mod) % mod; }
  constexpr void smul(int &a, int b, int mod = MOD) { a = modmul(a, b, mod); }
  constexpr int modpow(int a, ll b, int mod = MOD) {
    int res = 1;
    while(b){
      if(b & 1) smul(res, a, mod);
      smul(a, a, mod);
      b>>=1;
    }
    return res;
  }
  constexpr int modinv(int a, int mod = MOD) {
    ll x = 0, y = 0;
    extgcd(a, mod, x, y);
    return (x % mod + mod) % mod;
  }
  
  template<int N, int mod = MOD> struct Factorial {
    int arr[N+1], inv[N+1];
    int operator[](int i) const { return arr[i]; }
    constexpr Factorial(): arr(), inv() {
      arr[0] = 1;
      for(int i=1;i<=N;i++) {
        arr[i] = (ll) i * arr[i-1] % mod;
      }
      inv[N] = modinv(arr[N], mod);
      for(int i=N-1;i>=0;i--) {
        inv[i] = (ll) (i+1) * inv[i+1] % mod;
      }
    }
    int C(int n, int r) {
      if(n < 0 || r < 0 || n < r) return 0;
      return modmul(arr[n], modmul(inv[r], inv[n - r], mod), mod);
    }
  };
  
  /// }}}--- ///
  
  constexpr int N = 1e5 + 10;
  constexpr Factorial<N> fact;

