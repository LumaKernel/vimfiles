snippet     ntt
options     head
  // require modint library
  /// NTT Library {{{ ///
  template<ll mod, ll primitive>
  struct NTT {
    const ll Mod = mod;
    using Int = ModInt<mod>;
    vector<Int> fft(vector<Int> a, bool inv = 0) {
      int n = a.size(), n2 = n / 2;
      if(n == 1) return a;
      vector<Int> a0(n2), a1(n2);
      for(int i = 0; i < n2; i++) a0[i] = a[i*2], a1[i] = a[i*2+1];
      a0 = fft(a0); a1 = fft(a1);
      Int zeta(modpow(primitive, (mod - 1) / n, mod));
      if(inv) zeta = zeta.inv();
      Int tmp(1);
      for(int i = 0; i < n; i++) {
        int ii = i;
        if(inv) ii = n - i;
        a[i] = a0[ii % n2] + tmp * a1[ii % n2];
        if(inv) a[i] /= n;
        tmp *= zeta;
      }
      return a;
    }
    template<typename T> vector<Int> conv(vector<T> at, vector<T> bt) {
      int deg = at.size() + bt.size();
      int n = 1;
      while(n < deg) n <<= 1;
      vector<Int> a(n), b(n);
      for(int i = 0; i < (int) at.size(); i++) a[i] = Int(at[i]);
      for(int i = 0; i < (int) bt.size(); i++) b[i] = Int(bt[i]);
      a = fft(a); b = fft(b);
      vector<Int> c(n);
      for(int i = 0; i < n; i++) c[i] = a[i] * b[i];
      return fft(c, 1);
    }
  };
  /// }}}--- ///
  
  NTT<(1 << 25) * 5 + 1, 3> ntt1;
  NTT<(1 << 26) * 7 + 1, 3> ntt2;
  // NTT<(1 << 21) * 3 * 3 * 7 * 7 + 1, 5> ntt3;
  // NTT<(1 << 21) * 3 * 7 * 23 + 1, 5> ntt4;
  // NTT<(1 << 24) * 73 + 1, 3> ntt5;
  
  template<typename T>
  vector<ll> conv(vector<T> a, vector<T> b) {
    auto c1 = ntt1.conv(a, b);
    auto c2 = ntt2.conv(a, b);
    vector<ll> c(c1.size());
    for(int i = 0; i < (int) c.size(); i++) {
      // garner (inplace)
      ll x = c1[i].val;
      ll v1 = (c2[i].val - c1[i].val);
      v1 = (v1 % ntt2.Mod + ntt2.Mod) % ntt2.Mod;
      v1 = v1 * modinv(ntt1.Mod, ntt2.Mod) % ntt2.Mod;
      x += v1 * ntt1.Mod;
      c[i] = x;
    }
    return c;
  }

