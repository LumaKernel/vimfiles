snippet     dump
options     head
  // #undef DEBUG
  // #define DEBUG
  /// {{{ DEBUG --- ///
  template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? ", " : ""); o << "}"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? " " : ""); } return o; }
  #ifdef DEBUG
  #ifdef USE_COUT
  #define dump(...) (cout<<"["<<__LINE__<< "] "<<#__VA_ARGS__<<" = "<<make_tuple(__VA_ARGS__)<<"\n")
  #else
  #define dump(...) (cerr<<"["<<__LINE__<< "] "<<#__VA_ARGS__<<" = "<<make_tuple(__VA_ARGS__)<<"\n")
  #endif
  template<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}
  template<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?"":", ") << get<n>(t); _ot<n+1>(os, t); }
  template<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << "("; _ot<0>(o, t); o << ")"; return o; }
  template<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << "(" << p.first << ", " << p.second << ")"; return o; }
  #else
  #define dump(...) (0)
  #endif
  /// }}}--- ///
  ${0}

snippet     ostreamvector
options     head
  template <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? ", " : ""); o << "}"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? " " : ""); } return o; }
  ${0}

snippet     yes
alias       possible
options     head
  #define POS(x) cout<<((x)?"POSSIBLE":"IMPOSSIBLE")<<endl;
  #define Pos(x) cout<<((x)?"Possible":"Impossible")<<endl;
  #define YES(x) cout<<((x)?"YES":"NO")<<endl;
  #define Yes(x) cout<<((x)?"Yes":"No")<<endl;
  #define yes(x) cout<<((x)?"yes":"no")<<endl;
  ${0}

snippet     uniq
options     head
  #define uniq(v) sort(begin(v), end(v)), (v).erase(unique(begin(v), end(v)), end(v))
  ${0}

snippet     smax
alias       smin
options     head
  template <class T, class U> inline void smax(T &a, U b) { a = a > b ? a : b; }
  template <class T, class U> inline void smin(T &a, U b) { a = a < b ? a : b; }
  ${0}

snippet     neighbor4
alias       4
options     head
  int dx[] = {1, 0, -1, 0};
  int dy[] = {0, -1, 0, 1};
  ${0}

snippet     neighbor8
alias       8
options     head
  int dx[] = {1, 0, -1, 0, 1, 1, -1, -1};
  int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};
  ${0}

snippet     time
options     head
  // you must write return 0; !!
  // time measuring {{{
  #ifdef DEBUG
  #ifdef USE_COUT
  #define main __main(); int main() { clock_t beg = clock(); __main(); clock_t end = clock(); cout << "time: " << double(end - beg) / CLOCKS_PER_SEC << "s" << endl; } int __main
  #else
  #define main __main(); int main() { clock_t beg = clock(); __main(); clock_t end = clock(); cerr << "time: " << double(end - beg) / CLOCKS_PER_SEC << "s" << endl; } int __main
  #endif
  #endif
  // }}}
  ${0}

snippet     safeout
options     head
  // safe output arg1 / arg2
  // never forget to use fixed
  /// safeout {{{ ///
  void safeout(long long sum, long long m) {
    using ld = long double;
    long long f = sum / m;
    ld s = ld(sum % m) / (ld) m;
    if(f >= 10) {
      s += sum % 10;
      cout << f/10 << s << endl;
    } else {
      cout << (ld) sum / (ld) m << endl;
    }
  }
  /// }}} ///
  ${0}

snippet     outside
alias       inside outside
options     head
  if(${1:ny} < 0 || ${2:nx} < 0 || $1 >= h || $2 >= w) continue;
  ${0}

# 緊急用
snippet     rep
options     head
  #define rep(i, a, b) for(ll i = (ll) a; i < (ll) b; i++)
  #define repi(i, a, b) for(ll i = (ll) a; i <= (ll) b; i++)
  #define rrep(i, a, b) for(ll i = (ll) b - 1; i >= (ll) a; i--)
  #define rrepi(i, a, b) for(ll i = (ll) b; i >= (ll) a; i--)
  ${0}

