snippet     mods
alias       fact comb
options     head
  /// --- modulo Library {{{ ///
  constexpr ll extgcd(ll a, ll b, ll& x, ll& y) {
    if(b==0) {
      x = 1; y = 0;
      return a;
    }
    ll d = extgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
  }
  constexpr ll modpow(ll a, ll b, ll mod = static_cast<int>(1e9 + 7)) {
    a = (a % mod + mod) % mod;
    ll r = 1;
    while(b){
      if(b & 1) r = r * a % mod;
      a = a * a % mod;
      b >>= 1;
    }
    return r;
  }
  constexpr ll modinv(ll a, ll mod = static_cast<int>(1e9 + 7)) {
    a = (a % mod + mod) % mod;
    ll x = 0, y = 0;
    extgcd(a, mod, x, y);
    return (x % mod + mod) % mod;
  }
  
  template<int N, int mod = static_cast<int>(1e9 + 7)> struct Factorial {
    int arr[N+1], inv[N+1];
    long long operator[](int i) const { return arr[i]; }
    constexpr Factorial(): arr(), inv() {
      arr[0] = 1;
      for(int i = 1; i <= N; i++) {
        arr[i] = (long long) i * arr[i - 1] % mod;
      }
      inv[N] = modinv(arr[N], mod);
      for(int i = N-1; i >= 0; i--) {
        inv[i] = (long long) (i + 1) * inv[i + 1] % mod;
      }
    }
    long long C(int n, int r) const {
      if(n < 0 || r < 0 || n < r) return 0;
      return (((ll) arr[n] * inv[r]) % mod * inv[n - r]) % mod;
    }
  };
  /// }}}--- ///
  
  // constexpr int N = 1e5 + 10;
  // constexpr Factorial<N, mod> fact;

