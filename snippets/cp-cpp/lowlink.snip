# verify
# bridge : https://beta.atcoder.jp/contests/arc039/submissions/2136670
# articulation : http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723146#1
snippet     lowlink
abbr        Lowlink(int size);calc();
options     head
  /// --- Lowlink Library {{{ ///
  
  // undirected graph
  // count edges
  // construct : (int size)
  // do : calc()
  struct Lowlink {
    struct Edge {
      int to, idx;
      Edge(int to, int idx): to(to), idx(idx) {}
    };
    int size;
    int edgeSize = 0;
    vector< vector< Edge > > g;
    VI ord, low;
  
    VI used;
    VI isBridge, isArticulation;
    Lowlink(int n): size(n), g(n), ord(n), low(n) {}
  
    void addEdge(int a, int b) {
      g[a].emplace_back(b, edgeSize);
      g[b].emplace_back(a, edgeSize);
      edgeSize++;
    }
  
    void calc() {
      used.assign(size, 0);
      isBridge.assign(edgeSize, 0);
      isArticulation.assign(size, 0);
  
      int k = 0;
      dfs(0, -1, k);
    }
  
    // p just means "just before"
    private :
    void dfs(int i, int p, int &k) {
      used[i] = 1;
      ord[i]=low[i]=k++;
      isArticulation[i] = 0;
      int DFSTreeDegree = 0;
      for(Edge edge : g[i]) {
        int j = edge.to;
        int idx = edge.idx;
        if(used[j]) {
          if(j != p) {
            // back edge
            smin(low[i], ord[j]);
          }
        } else {
          // on dfs-tree
          DFSTreeDegree++;
          dfs(j, i, k);
          smin(low[i], low[j]);
          isBridge[idx] = ord[i] < low[j];
          if(p != -1 && ord[i] <= low[j]) {
            isArticulation[i] = 1;
          }
        }
      }
      if(p == -1 && DFSTreeDegree > 1) {
        isArticulation[i] = 1;
      }
    }
  };
  
  /// }}}--- ///
  

