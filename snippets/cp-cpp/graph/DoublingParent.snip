# verify : https://beta.atcoder.jp/contests/arc039/submissions/2136670
snippet     doublingparent
abbr        DoublingParent(tree);
options     head
  // size is non-zero
  /// --- Doubilng Parent Library {{{ ///
  
  // tree
  struct DoublingParent {
    int size, logSize;
    vector< vector<int> > tree;
    vector<int> depth; // 0-indexed
    vector< vector<int> > par; // for doubling
    DoublingParent(vector< vector<int> > tree): size(tree.size()), tree(tree) {
      calc();
    }
  
    private:
    void calc() {
      // calc log_2 size
      logSize = 32 - __builtin_clz(size);
      if(logSize == 0) logSize++;
  
      depth.assign(size, 0);
      par.assign(size, vector<int>(logSize, -1));
      dfs(0);
  
      for(int k = 1; k < logSize) {
        for(int i = 0; i < size; i++) {
          int p = par[i][k-1];
          if(p == -1) {
            par[i][k] = -1;
            continue;
          }
          par[i][k] = par[p][k-1];
        }
      }
    }
  
    void dfs(int i, int p = -1, int d = 0) {
      depth[i] = d;
      par[i][0] = p;
      for(int j: tree[i]) if(j != p) {
        dfs(j, i, d+1);
      }
    }
  
    public:
    int LCA(int a, int b) {
      if(depth[a] < depth[b]) swap(a,b);
      for(int k = logSize - 1; k >= 0; k--) {
        int na = par[a][k];
        if(na == -1) continue;
        if(depth[na] < depth[b]) continue;
        a = na;
      }
      if(a==b) return a;
      for(int k = logSize - 1; k >= 0; k--) {
        int na = par[a][k];
        int nb = par[b][k];
        if(na==nb) continue;
        a=na;b=nb;
      }
      return par[a][0];
    }
  };
  
  /// }}}--- ///

