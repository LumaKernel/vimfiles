[[plugins]]
repo = 'Shougo/dein.vim'

# カーソル位置によってft切り替え
# これでtomlファイルをウハウハ編集
[[plugins]]
repo = 'osyo-manga/vim-precious'
depends = ['context_filetype.vim']

# カーソル位置のコンテキストのft判定
[[plugins]]
repo = 'Shougo/context_filetype.vim'

# toml syntax
[[plugins]]
repo = 'cespare/vim-toml'
on_ft = 'toml'

# comment out
[[plugins]]
repo = 'tyru/caw.vim'
hook_add = '''
  nmap <C-I> <Plug>(caw:hatpos:toggle)
  vmap <C-I> <Plug>(caw:hatpos:toggle)
'''

# molokai
[[plugins]]
repo = 'tomasr/molokai'

# typescript
[[plugins]]
repo = 'leafgarland/typescript-vim'

# restart
[[plugins]]
repo = 'tyru/restart.vim'

[[plugins]]
repo = 'vim-scripts/TwitVim'
hook_add = '''
  if has('mac')
    let twitvim_browser_cmd = 'open'
  endif
  " TODO : for windows
  let twitvim_force_ssl = 1
  let twitvim_count = 40

  nnoremap <SPACE>t :PosttoTwitter<CR>
'''

# gitgutter
[[plugins]]
repo = 'airblade/vim-gitgutter'

# NERDTree
[[plugins]]
repo = 'scrooloose/nerdtree'
hook_add = '''
  nnoremap <silent> <SPACE>n :NERDTree<CR>
'''

[[plugins]]
repo = 'Xuyuanp/nerdtree-git-plugin'
depends = ['nerdtree']

[[plugins]]
repo = 'Shougo/vimshell.vim'
depends = ['vimproc.vim']

#neosippet
[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = ['neosnippet-snippets']
hook_add = '''
  let g:neosnippet#snippets_directory='~/vimfiles/snippets/'
'''

[[plugins]]
repo = 'Shougo/neosnippet-snippets'
hook_add = '''
  imap <C-k> <Plug>(neosnippet_expand_or_jump)
  smap <C-k> <Plug>(neosnippet_expand_or_jump)
  xmap <C-k> <Plug>(neosnippet_expand_or_target)
'''

# neocomplete {{{
[[plugins]]
repo = 'Shougo/neocomplete.vim'
hook_add = '''
	let g:acp_enableAtStartup = 0
	" Use neocomplete.
	let g:neocomplete#enable_at_startup = 1
	" Use smartcase.
	let g:neocomplete#enable_smart_case = 1

	" Define dictionary.
	let g:neocomplete#sources#dictionary#dictionaries = {
	    \ 'default' : '',
	    \ 'vimshell' : $HOME.'/.vimshell_hist',
	    \ 'scheme' : $HOME.'/.gosh_completions'
	    \ }

	" Define keyword.
	if !exists('g:neocomplete#keyword_patterns')
	    let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns['default'] = '\h\w*'

	" Plugin key-mappings.
	inoremap <expr><C-g>     neocomplete#undo_completion()
	inoremap <expr><C-l>     neocomplete#complete_common_string()

	" Recommended key-mappings.
	" <CR>: close popup and save indent.
	inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
	function! s:my_cr_function()
	  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
	  " For no inserting <CR> key.
	  "return pumvisible() ? "\<C-y>" : "\<CR>"
	endfunction
	" <TAB>: completion.
	inoremap <silent><expr> <TAB>
	      \ pumvisible() ? "\<C-n>" :
	      \ <SID>check_back_space() ? "\<TAB>" :
	      \ neocomplete#start_manual_complete()
	function! s:check_back_space() abort "{{{
	  let col = col('.') - 1
	  return !col || getline('.')[col - 1]  =~ '\s'
	endfunction"}}}
	" <C-h>, <BS>: close popup and delete backword char.
	inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
	inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
	" Close popup by <Space>.
	"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

	" AutoComplPop like behavior.
	"let g:neocomplete#enable_auto_select = 1

	" Shell like behavior (not recommended.)
	"set completeopt+=longest
	"let g:neocomplete#enable_auto_select = 1
	"let g:neocomplete#disable_auto_complete = 1
	"inoremap <expr><TAB>  pumvisible() ? "\<Down>" :
	" \ neocomplete#start_manual_complete()

	" Enable omni completion.
	autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
	autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
	autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
	autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
	autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

	" Enable heavy omni completion.
	if !exists('g:neocomplete#sources#omni#input_patterns')
	  let g:neocomplete#sources#omni#input_patterns = {}
	endif
	if !exists('g:neocomplete#force_omni_input_patterns')
	  let g:neocomplete#force_omni_input_patterns = {}
	endif
	"let g:neocomplete#sources#omni#input_patterns.php =
	"\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
	"let g:neocomplete#sources#omni#input_patterns.c =
	"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
	"let g:neocomplete#sources#omni#input_patterns.cpp =
	"\ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

	" For perlomni.vim setting.
	" https://github.com/c9s/perlomni.vim
	let g:neocomplete#sources#omni#input_patterns.perl =
	\ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

	" For smart TAB completion.
	"inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
	"        \ <SID>check_back_space() ? "\<TAB>" :
	"        \ neocomplete#start_manual_complete()
	"  function! s:check_back_space() "{{{
	"    let col = col('.') - 1
	"    return !col || getline('.')[col - 1]  =~ '\s'
	"  endfunction"}}}
'''
# }}}

# Haskell{{{

[[plugins]]
repo = 'dag/vim2hs'

[[plugins]]
repo = 'eagletmt/ghcmod-vim'
hook_add = '''
  augroup ghcmodcheck
    " autocmd! BufWritePost <buffer> GhcModCheckAsync
    " Todo :
  augroup END
'''

# }}}

# C++{{{
[[plugins]]
repo = 'vim-jp/cpp-vim'

[[plugins]]
repo = 'osyo-manga/vim-snowdrop'
depends = ['neocomplete.vim']

# }}}

[[plugins]]
repo = 'Shougo/vimproc.vim'
hook_add = '''
  let g:vimproc#download_windows_dll = 1
'''

